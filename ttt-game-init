(ns tic-tac-toe.core)

(def indexes ; this is the terminal set
  [[0 0 0] [0 0 1] [0 0 2] [0 1 0] [0 1 1] [0 1 2] [0 2 0] [0 2 1] [0 2 2]
   [1 0 0] [1 0 1] [1 0 2] [1 1 0] [1 1 1] [1 1 2] [1 2 0] [1 2 1] [1 2 2]
   [2 0 0] [2 0 1] [2 0 2] [2 1 0] [2 1 1] [2 1 2] [2 2 0] [2 2 1] [2 2 2]])

(def all-winning-indexes [
   ; y-axis                       
   [[0 0 0] [1 0 0] [2 0 0]] 
   [[0 1 0] [1 1 0] [2 1 0]]
   [[0 2 0] [1 2 0] [2 2 0]]
   
   [[0 0 1] [1 0 1] [2 0 1]]
   [[0 1 1] [1 1 1] [2 1 1]]
   [[0 2 1] [1 2 1] [2 2 1]]
   
   [[0 0 2] [1 0 2] [2 0 2]]
   [[0 1 2] [1 1 2] [2 1 2]]
   [[0 2 2] [1 2 2] [2 2 2]]
   
   ; x-axis
   [[0 0 0] [0 1 0] [0 2 0]]
   [[1 0 0] [1 1 0] [1 2 0]]
   [[2 0 0] [2 1 0] [2 2 0]]
   
   [[0 0 1] [0 1 1] [0 2 1]]
   [[1 0 1] [1 1 1] [1 2 1]]
   [[2 0 1] [2 1 1] [2 2 1]]
   
   [[0 0 2] [0 1 2] [0 2 2]]
   [[1 0 2] [1 1 2] [1 2 2]]
   [[2 0 2] [2 1 2] [2 2 2]]
   
   ; z-axis
   [[0 0 0] [0 0 1] [0 0 2]]
   [[1 0 0] [1 0 1] [1 0 2]]
   [[2 0 0] [2 0 1] [2 0 2]]
   
   [[0 1 0] [0 1 1] [0 1 2]]
   [[1 1 0] [1 1 1] [1 1 2]]
   [[2 1 0] [2 1 1] [2 1 2]]
   
   [[0 2 0] [0 2 1] [0 2 2]]
   [[1 2 0] [1 2 1] [1 2 2]]
   [[2 2 0] [2 2 1] [2 2 2]]
   
   ; diagonals-xy
   [[0 0 0] [1 1 0] [2 2 0]]
   [[2 0 0] [1 1 0] [0 2 0]]
   
   [[0 0 1] [1 1 1] [2 2 1]]
   [[2 0 1] [1 1 1] [0 2 1]]
   
   [[0 0 2] [1 1 2] [2 2 2]]
   [[2 0 2] [1 1 2] [0 2 2]]
   
   ; diagonals-xz
   [[0 0 0] [0 1 1] [0 2 2]]
   [[0 0 2] [0 1 1] [0 2 0]]
   
   [[1 0 0] [1 1 1] [1 2 2]]
   [[1 0 2] [1 1 1] [1 2 0]]
   
   [[2 0 0] [2 1 1] [2 2 2]]
   [[2 0 2] [2 1 1] [2 2 0]]
   
   ; diagonals-yz
   [[0 0 0] [1 0 1] [2 0 2]]
   [[0 0 2] [1 0 1] [2 0 0]]
   
   [[0 1 0] [1 1 1] [2 1 2]]
   [[0 1 2] [1 1 1] [2 1 0]]
   
   [[0 2 0] [1 2 1] [2 2 2]]
   [[0 2 2] [1 2 1] [2 2 0]]
   
   ; diagonals-xyz
   [[0 0 0] [1 1 1] [2 2 2]]
   [[0 2 2] [1 1 1] [2 0 0]]
   [[0 0 2] [1 1 1] [2 2 0]]
   [[2 0 2] [1 1 1] [0 2 0]]
   
   ])

(defn create-game-board
  "Creates the 3x3x3 Tic-Tac-Toe game board."
  []
  [[["O" nil nil] ["x" "o" nil] [nil "o" nil]]
   [["x" nil nil] [nil "x" nil] [nil nil "x"]]
   [[nil nil nil] [nil nil nil] [nil nil nil]]]
  )

(def board (create-game-board)) ; for testing purposes only!

(defn create-player
  "Creates a Tic-Tac-Toe computer player."
  [char] ; strategy to be implemented --> this is what we will "evolve"
  {:token char
   :strategy "to be implemented"
   :wins 0
   :losses 0
   :ties 0})

(defn new-game
  "Initializes a new Tic-Tac-Toe game."
  []
  {:board (create-game-board)
   :player1 (create-player "O")
   :player2 (create-player "X")})

(defn get-value-at-index
  [board index]
  (get-in board index))

(defn first-turn?
  [board]
  (= [nil] (distinct board)))

(defn valid-spot?
  [board index]
  (= nil (get-value-at-index board index)))

(defn all-spots-taken?
  [board]
  (empty? (filter (fn [index] (= nil index)) (flatten board))))

(defn choose-random-spot
  "Returns an index representing a random, unoccupied spot on the board."
  [board]
  (let [index (rand-nth indexes)]
    (if (= nil (get-value-at-index board index))
      index
      (recur (rand-nth indexes)))))

(defn take-turn
  [board index player]
  (if (valid-spot? board index)
    (assoc board index (get player :token))
    (assoc board (choose-random-spot board) (get player :token))))

(defn winner-exists? 
  [board indexes]
  (apply = (map #(get-value-at-index board %) indexes)))

(defn winner-on-indexes 
  [board indexes]
  (if (winner-exists? board indexes)
    (get-value-at-index board (first indexes))
    nil))

(defn winner
  "Returns the winner of the game, or nil if there is no winner yet.
   TENTATIVE VERSION:
   I need to change this function to return the PLAYER, and not the winning token!"
  [board] 
  (some #(winner-on-indexes board %) all-winning-indexes))

; DO I NEED TO PASS OVER BOARD AS ARGUMENT OR GAME? 
; ISNT GAME MORE SUITABLE AS AN ARG IF WE HAVE MULTIPLE GAMES GOING ON SIMULATANEOUSLY?

(defn game-over?
  "Determines whether or not the game is over yet."
  [board]
  (or 
    (all-spots-taken? board) 
    (if (not (= nil (winner board)))
      true
      false)))

; ================================ Functions Set ================================

(defn make-program-into-fn
  "Takes a GP program represented as a list, with input index,
   and transforms it into a function that can be called on an input."
  [program]
  (eval (list 'fn '[index board player] program)))

(defn program-size
  "Finds the size of the program, i.e. number of nodes in its tree."
  [prog]
  (if (not (seq? prog))
    1
    (count (flatten prog))))

(def instruction-set
  '{if-mine-at-index 3
    if-theirs-at-index 3
    if-mine-at-indexes 4
    if-theirs-at-indexes 4})
    
; Is this the approach you are taking or is your approach different? 
; This is what I could come up with. Once you've come up with a set we could compare and see which one to adopt.

(def if-mine-at-index
  '(if (= (get player :token) (get-value-at-index board index))))

(def if-theirs-at-index
  '(if (and
         (not (= (get player :token) (get-value-at-index board index)))
         (not (= nil (get-value-at-index board index))))))

(def if-mine-at-indexes
  '(if (and 
         (= (get player :token) (get-value-at-index board index1))
         (= (get player :token) (get-value-at-index board index2)))))

(def if-theirs-at-indexes
  '(if (and  
         (and
           (not (= (get player :token) (get-value-at-index board index1)))
           (not (= nil (get-value-at-index board index1))))
         (and
           (not (= (get player :token) (get-value-at-index board index2)))
           (not (= nil (get-value-at-index board index2)))))))
           
;This is more what I was thinking of for our function set. Of course nill will only be used
;for the if-empty. For the others I need to know what value get-value would return if the index
;is X or O. 5 functions should be enough for the players to work with.
(defn if-x-at-index
  [vector1 vector2 vector3]
  (if (= (get-value-at-index vector1) "x")
    vector2
    vector3)
  )

(defn if-o-at-index
  [vector1 vector2 vector3]
  (if (= (get-value-at-index vector1) "o")
    vector2
    vector3)
  )

(defn if-index-empty
  [vector1 vector2 vector3]
  (if (= (get-value-at-index vector1) nill)
    vector2
    vector3)
  )

(defn if-2-x-indexes
  [vector1 vector2 vector3 vector4]
  (if (and (= (get-value-at-index vector1) "x") 
           (= (get-value-at-index vector2) "x"))
    vector3
    vector4))

(defn if-2-o-indexes
  [vector1 vector2 vector3 vector4]
  (if (and (= (get-value-at-index vector1) "o") 
           (= (get-value-at-index vector2) "o"))
    vector3
    vector4))
    
(def function-set
  (list if-mine-at-index if-theirs-at-index if-mine-at-indexes if-theirs-at-indexes))
  
(def function-set
  ( '(if-x-at-index if-o-at-index if-empty-at-index if-2-x-indexes if-2-o-indexes)))

(defn select-terminal
  "Selects a random terminal for the program -- the terminal is any index value."
  []
  (rand-nth indexes))

(defn select-fun
  "Selects a random function for the program (from the function set)."
  []
  (rand-nth function-set))

; generate-prog does not work for some reason. have to figure out whats up.
(defn generate-prog
  "Generates a program of the given depth, using random functions and terminals."
  [depth]
  (if (zero? depth)
    (select-terminal)
    (let [func (select-fun)]
      (list func ; select a random function and recursively call generate-prog to
                 ; fill out the subchildren of the node
            (repeatedly 3 (generate-prog (dec depth)))))))

(generate-prog 1)
